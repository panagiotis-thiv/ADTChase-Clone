![run-tests](../../workflows/run-tests/badge.svg)

## 2024 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/


### Προσωπικά στοιχεία

__Όνομα__: Παναγιώτης Θηβαίος

__Α.Μ.__: sdi2300271

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Άσκηση 1
- Άσκηση 2
- Άσκηση 3
- Άσκηση 4
- Άσκηση 6

### Documentation

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.

#### Σχετικά με την state:

- Πιστεύω πως ο κώδικας είναι αρκετά κατανοητός αφού δεν κάνω κάτι πολύ περίπλοκο. <br> </br>
Αυτό όμως που θα μπορούσα να αναφέρω είναι ο τρόπος που αλλάζω το speed factor. Το πρόβλημα ήταν ότι το speed factor θα πρέπει να αλλάζει μόνο την πρώτη φορά που το score γίνει 100, και όχι κάθε φορά που είναι 100 (+ ότι τρέχουμε την state 60 φορές + ότι μπορεί να μειωθεί το score και να ξαναγίνει 100).
Ο πρώτος έλεγχος είναι ο αναμενόμενος, μετά διαιρώ κάθε φορά το speed factor (με 1.1 αφού αυξάνεται κατά 10%) μέχρι να γίνει 1. Με αυτόν τον τρόπο μπορώ να ξέρω πόσες φορές έχει αυξήθει.
Άμα έχει αυξηθεί 1,2,3 τότε το score κάποτε έχει γίνει 100,200,300 κτλπ. Τέλος το συγκρίνω με το πηλίκο speed_factor/score ώστε να καταλάβω άμα πρέπει να αυξήσω το speed factor ή όχι (πχ. άμα το πηλίκο είναι 3 και οι φορές που διαιρέθηκε το speed factor είναι 2 τότε θα πρέπει να αυξηθεί).

#### Σχετικά με την state_test:

**Αρχικά να αναφέρω ότι στην αρχή που έγραφα τα tests δεν ήξερα ότι μπορούσα να γνωρίζω την θέση ή το είδος του αντικειμένου (δεν είχα καταλάβει ότι από την λίστα που παίρνω από την state_objects μπορώ να παίρνω το node και από αυτό αυτές τις πληροφορίες). Παρόλα αυτά, δεν ήθελα να αλλάξω τα tests αφού δουλεύουν αλλά επειδή είναι και ενδιαφέρον ο τρόπος που τα έφτιαξα (+ μου πήραν υπερβολικά πολύ χρόνο).**


- Γενικές σημειώσεις:
Χρησιμοποιώ 3 state_objects τακτικά για να βρω: 1. Πόσοι αστεροειδείς υπάρχουν σε όλο το παιχνίδι (στην πραγματικότητα είναι μαζί με τις σφαίρες αλλά δεν μας πειράζει πολύ αυτό). 2. Πόσοι αστεροειδείς είναι κοντά στο διαστημόπλοιο. 3. Πόσες σφαίρες έχουν δημιουργηθεί είτε σε όλο το παιχνίδι (Α) είτε κοντά (Β).
Ο τρόπος που κάνω τον τελευταίο έλεγχο είναι καλώντας την state_objects για μια "γραμμή". Επειδή γνωρίζω ότι οι σφαίρες δημιουργούνται στην κατεύθυνση που κοιτάει το διαστημόπλοιο και ότι στην αρχή κοιτάει προς τα πάνω, άμα ψάξω για όλα τα αντικείμενα σε μία ευθεία πάνω από το διαστημόπλοιο τότε ότι βρω θα είναι πολύ πιθανόν σφαίρα (για να είναι αστεροείδεις οι πιθανότητες είναι υπερβολικά λίγες). Σχεδόν όλα τα tests γίνονται σύμφωνα με αυτές τις κλήσεις.


- Έλεγχος συγκρούσεων
Για τις συγκρούσεις χρησιμοποιείται και το score. Ο βασικός έλεγχος βασίζεται στην αλλαγή του score, άμα ποτέ δεν άλλαζε (συγκεκριμένα δεν μειωνόταν) τότε ποτέ δεν θα γινόταν κάποια σύγκρουση. Αυτό που ελέγχουν οι TEST_ASSERT είναι η κατάσταση του παιχνιδιού πριν και μετά την σύγκρουση.
Α. Αστεροειδής - Διαστημόπλοιο: Θα πρέπει όλοι οι αστεροειδείς (state_object 1) να έχουν μειωθεί κατά 1, οι "κοντά" αστεροειδείς (state_object 2) να έχουν μειωθεί κατά 1 και το score δία 2.
Β. Αστεροειδής - Σφαίρα. Θα πρέπει όλες οι σφαίρες (και κοντά) (state_object 3Α & 3Β) να έχουν μειωθεί κατά 1 και να έχει αλλάξει το score (-10). Από την άλλη δεν θα πρέπει να έχει αλλάξει το state_object 1 και 2 αφού στην state_object 1,2 συμπεριλάβονται και οι σφαίρες. Όταν γίνει η σύγκρουση θα δημιουργηθούν άλλοι 2 αστεροειδείς. Οπότε: -1 (σφαίρα) -1 (αστεροειδής που συγκρούστηκε) + 2 (αστεροειδείς από την σύγκρουση) = 0.
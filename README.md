![run-tests](../../workflows/run-tests/badge.svg)

## 2024 Project 1

Εκφώνηση: https://k08.chatzi.org/projects/project1/


### Προσωπικά στοιχεία

__Όνομα__: Παναγιώτης Θηβαίος

__Α.Μ.__: sdi2300271

### Ασκήσεις που παραδίδονται

Συμπληρώστε εδώ τις ασκήσεις (και τυχόν bonus) που παραδίδετε. Αν κάποια άσκηση
βρίσκεται σε μη αναμενόμενα αρχεία αναφέρετε και τα αρχεία αυτά.

- Άσκηση 1
- Άσκηση 2
- Άσκηση 3
- Άσκηση 4
- Άσκηση 6

### Documentation

Συμπληρώστε εδώ __όσο documentation χρειάζεται__ ώστε οι βαθμολογητές να
κατανοήσουν πλήρως τις λύσεις σας και να τις βαθμολογήσουν ανάλογα. Αυτό θα
πρέπει να γίνει ανεξάρτητα με το αν ο κώδικάς σας είναι καλά σχολιασμένος,
πράγμα που συνιστάται.

### [Competition Changelog]
Αρχικά να αναφέρω πως παρόλο που άρχισα να δουλεύω πάνω στο παιχνίδι από όταν τελείωσε η εργασία δεν έγραψα πότε εδώ λίγο documentation το οποίο δεν είναι σωστό (πιο πολύ γιατί ήθελα να γράψω αφού φτιάξω κάτι ικανοποιητικό πρώτα).
Για ποιο λόγο το κάνω αυτό τέλη Αυγούστου; <br> </br>
Πρώτων γιατί μου δόθηκε η ευκαιρία αφού δεν έγινε το competition πριν τελειώσει το εξάμηνο και δεύτερων γιατί μ' αρέσει αρκετά. <br> </br>
Τι έκανα όμως τόσο καιρό;<br> </br>
Παρόλο που δεν είναι σωστό να πολυλογώ εδώ δεν αντέχω να μην γράψω κάτι. Τους πρώτους 2 μήνες (μετά το τέλος της εργασίας) προσπάθησα να υλοποιήσω μια καλύτερη δομή, συγκεκριμένα ένα quadtree. Κατάφερα τελικά να το φτιάξω μέχρι που να δουλεύει η αναζήτηση αλλά υπήρχε θέμα στην σύγκρουση το οποίο ήθελε αλλαγή σχεδόν όλης της δομής, οπότε έχασα 2 μήνες χωρίς να έχω κάνει τίποτα.. Μετά ανά διάφορα διαστήματα όποτε είχα όρεξη ασχολιόμουν με το παιχνίδι για λίγο. Την πιο πολύ δουλειά την έκανα την τελευταία βδομάδα (σήμερα είναι 28/8). Τώρα αρχίζει το σωστό documentation. <br> </br>
#### [Menu]
Το πρώτο πράγμα που έφτιαξα ήταν το menu. Από ότι θυμάμαι μου είχε πάρει λίγη ώρα να καταλάβω πως ακριβώς θα δουλεύει αλλά το βρήκα. Στην ουσία στο ίδιο παράθυρο "ζωγραφίζω" εγώ ότι θέλω ανά frame χωρίς να εμπλέκεται η state. Ο κώδικας δεν είναι τέλειος αλλά δουλεύει. Έχω 2 μεταβλητές οι οποίες μου λένε ποιο menu χρησιμοποιείται κάθε στιγμή και ποιο menu κάνω "hover".<br></br>
Κατάφερα να κρατήσω όλο τον κώδικα λογικής στην game.c και η interface.c έχει καθαρά μόνο interface κώδικα. Μετά απλά κοιτάω τι κουμπί πατάω και ανάλογα με αυτό αυξάνω ή μειώνω την αντίστοιχη μεταβλητή. Λίγο πιο περίπλοκο γίνεται με τα pages, που είναι στην ουσία οι επιλογές "μέσα" στο κάθε menu. Άμα αρχίσω να γράφω για αυτό δεν θα τελειώσω πότε, μπορείτε άνετα να δείτε τον τρομερό κώδικα μου και να μην καταλάβετε τίποτα :) (game.c + menu.c).
### [Store]
Αυτό που θα περίμενε κάποιος όταν διαβάζει store. Σε συνδυασμό με τα global stats μπορείς να αλλάζεις το όπλο, την ζωή του διαστημόπλοιου σε όλα τα levels (states).
### [Global Stats]
Ένα γενικό struct που έχει πληροφορίες που δεν είναι αποκλειστικές σε κάποιο state αλλά γενικές. Αυτό προέκυψε όταν πήγα να φτιάξω και άλλο level (διαφορετικό state) και παρατήρησα ότι τα coins, η ζωή και τα όπλα ήταν τελείως χαλασμένα. Εδώ άλλαξα πάρα πολύ κώδικα (μερών δουλειάς που είχα κάνει) γιατί αλλιώς δεν θα έβγαζα ποτέ άκρη. Άμα δείτε το global_stats.c θα καταλάβετε αμέσως πως δουλεύει (πιστεύω).
### [Levels]
Στην αρχή σκεφτόμουν πως θα έπρεπε κάθε level να είναι ένα τελείως διαφορετικό state, αλλά επειδή δεν αλλάζουν πολλά μεταξύ κάθε level το έκανα με άλλο τρόπο. Έφτιαξα ένα ξεχωριστό struct που παίρνει η state_create μέσα στο οποίο βρίσκονται πληροφορίες για τους αστεροειδής (ζωή, ταχύτητα, κέρδη) και κάποιες άλλες γενικές πληροφορίες. Όποτε κάθε φορά απλά φτιάχνω ένα καινούργιο "level" με τους αριθμούς που θέλω και μετά το βάζω σαν όρισμα στην state_create.<br></br>
Δυστυχώς επειδή δεν έγραφα changelog κάθε φορά που έφτιαχνα κάτι δεν μπορώ να γράψω πάρα πολλές λεπτομέρειες, αλλά αυτά είναι τα πιο βασικά.<br></br>Τέλος έφτιαξα και δύο διαφορετικά τελείως state που μπορείς να κερδίσεις coins με "λίγο" τύχη :) .

#### Σχετικά με την state:

- Πιστεύω πως ο κώδικας είναι αρκετά κατανοητός αφού δεν κάνω κάτι πολύ περίπλοκο. <br> </br>
Αυτό όμως που θα μπορούσα να αναφέρω είναι ο τρόπος που αλλάζω το speed factor. Το πρόβλημα ήταν ότι το speed factor θα πρέπει να αλλάζει μόνο την πρώτη φορά που το score γίνει 100, και όχι κάθε φορά που είναι 100 (+ ότι τρέχουμε την state 60 φορές + ότι μπορεί να μειωθεί το score και να ξαναγίνει 100).
Ο πρώτος έλεγχος είναι ο αναμενόμενος, μετά διαιρώ κάθε φορά το speed factor (με 1.1 αφού αυξάνεται κατά 10%) μέχρι να γίνει 1. Με αυτόν τον τρόπο μπορώ να ξέρω πόσες φορές έχει αυξήθει.
Άμα έχει αυξηθεί 1,2,3 τότε το score κάποτε έχει γίνει 100,200,300 κτλπ. Τέλος το συγκρίνω με το πηλίκο speed_factor/score ώστε να καταλάβω άμα πρέπει να αυξήσω το speed factor ή όχι (πχ. άμα το πηλίκο είναι 3 και οι φορές που διαιρέθηκε το speed factor είναι 2 τότε θα πρέπει να αυξηθεί).

#### Σχετικά με την state_test:

**Αρχικά να αναφέρω ότι στην αρχή που έγραφα τα tests δεν ήξερα ότι μπορούσα να γνωρίζω την θέση ή το είδος του αντικειμένου (δεν είχα καταλάβει ότι από την λίστα που παίρνω από την state_objects μπορώ να παίρνω το node και από αυτό αυτές τις πληροφορίες). Παρόλα αυτά, δεν ήθελα να αλλάξω τα tests αφού δουλεύουν αλλά επειδή είναι και ενδιαφέρον ο τρόπος που τα έφτιαξα (+ μου πήραν υπερβολικά πολύ χρόνο).**


- Γενικές σημειώσεις:
Χρησιμοποιώ 3 state_objects τακτικά για να βρω: 1. Πόσοι αστεροειδείς υπάρχουν σε όλο το παιχνίδι (στην πραγματικότητα είναι μαζί με τις σφαίρες αλλά δεν μας πειράζει πολύ αυτό). 2. Πόσοι αστεροειδείς είναι κοντά στο διαστημόπλοιο. 3. Πόσες σφαίρες έχουν δημιουργηθεί είτε σε όλο το παιχνίδι (Α) είτε κοντά (Β).
Ο τρόπος που κάνω τον τελευταίο έλεγχο είναι καλώντας την state_objects για μια "γραμμή". Επειδή γνωρίζω ότι οι σφαίρες δημιουργούνται στην κατεύθυνση που κοιτάει το διαστημόπλοιο και ότι στην αρχή κοιτάει προς τα πάνω, άμα ψάξω για όλα τα αντικείμενα σε μία ευθεία πάνω από το διαστημόπλοιο τότε ότι βρω θα είναι πολύ πιθανόν σφαίρα (για να είναι αστεροείδεις οι πιθανότητες είναι υπερβολικά λίγες). Σχεδόν όλα τα tests γίνονται σύμφωνα με αυτές τις κλήσεις.


- Έλεγχος συγκρούσεων
Για τις συγκρούσεις χρησιμοποιείται και το score. Ο βασικός έλεγχος βασίζεται στην αλλαγή του score, άμα ποτέ δεν άλλαζε (συγκεκριμένα δεν μειωνόταν) τότε ποτέ δεν θα γινόταν κάποια σύγκρουση. Αυτό που ελέγχουν οι TEST_ASSERT είναι η κατάσταση του παιχνιδιού πριν και μετά την σύγκρουση.
Α. Αστεροειδής - Διαστημόπλοιο: Θα πρέπει όλοι οι αστεροειδείς (state_object 1) να έχουν μειωθεί κατά 1, οι "κοντά" αστεροειδείς (state_object 2) να έχουν μειωθεί κατά 1 και το score δία 2.
Β. Αστεροειδής - Σφαίρα. Θα πρέπει όλες οι σφαίρες (και κοντά) (state_object 3Α & 3Β) να έχουν μειωθεί κατά 1 και να έχει αλλάξει το score (-10). Από την άλλη δεν θα πρέπει να έχει αλλάξει το state_object 1 και 2 αφού στην state_object 1,2 συμπεριλάβονται και οι σφαίρες. Όταν γίνει η σύγκρουση θα δημιουργηθούν άλλοι 2 αστεροειδείς. Οπότε: -1 (σφαίρα) -1 (αστεροειδής που συγκρούστηκε) + 2 (αστεροειδείς από την σύγκρουση) = 0.

- Έλεγχος περιστροφής
Μπορούμε να καταλάβουμε καλύτερα προς τα που κοιτάει το διαστημόπλοιο με την βοήθεια της παρακάτω εντολής: 
```float rotation = atan2(state_info(state)->spaceship->orientation.y, state_info(state)->spaceship->orientation.x *(-1)) * RAD2DEG;```
Για παράδειγμα, επιστρέφει σχεδόν 90 (89.9) όταν κοιτάει προς τα πάνω, 45 (44.9) όταν κοιτάει προς τα αριστερά, κτλπ. Στα tests δεν μου δούλευε καλά άμα σύγκρινα κατευθείαν το rotation με 89.9 σε κάποια TEST_ASSERT, οπότε συγκρίνω το orientation.x και orientation.y με τις τιμές που αντιστοιχούν όταν το rotation είναι 44.9, 89.9 κτλπ.